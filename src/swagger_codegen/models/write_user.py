# coding: utf-8

from __future__ import absolute_import
from datetime import date, datetime  # noqa: F401
from enum import Enum  # noqa: F401

from typing import List, Dict  # noqa: F401

from swagger_codegen.models.base_model_ import Model  # noqa: F401
from swagger_codegen import util  # noqa: F401


class WriteUser(Model):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    def __init__(self, username: str=None, first_name: str=None, last_name: str=None, email: str=None, password: str=None, phone: str=None, user_status: int=None, height: float=None, born_on: datetime=None, gender: str=None):  # noqa: E501
        """WriteUser - a model defined in Swagger

        :param username: The username of this WriteUser.  # noqa: E501
        :type username: str
        :param first_name: The first_name of this WriteUser.  # noqa: E501
        :type first_name: str
        :param last_name: The last_name of this WriteUser.  # noqa: E501
        :type last_name: str
        :param email: The email of this WriteUser.  # noqa: E501
        :type email: str
        :param password: The password of this WriteUser.  # noqa: E501
        :type password: str
        :param phone: The phone of this WriteUser.  # noqa: E501
        :type phone: str
        :param user_status: The user_status of this WriteUser.  # noqa: E501
        :type user_status: int
        :param height: The height of this WriteUser.  # noqa: E501
        :type height: float
        :param born_on: The born_on of this WriteUser.  # noqa: E501
        :type born_on: datetime
        :param gender: The gender of this WriteUser.  # noqa: E501
        :type gender: str
        """
        self.swagger_types = {
            'username': str,
            'first_name': str,
            'last_name': str,
            'email': str,
            'password': str,
            'phone': str,
            'user_status': int,
            'height': float,
            'born_on': datetime,
            'gender': str
        }

        self.attribute_map = {
            'username': 'username',
            'first_name': 'first_name',
            'last_name': 'last_name',
            'email': 'email',
            'password': 'password',
            'phone': 'phone',
            'user_status': 'user_status',
            'height': 'height',
            'born_on': 'born_on',
            'gender': 'gender'
        }

        self._username = username
        self._first_name = first_name
        self._last_name = last_name
        self._email = email
        self._password = password
        self._phone = phone
        self._user_status = user_status
        self._height = height
        self._born_on = born_on
        self._gender = gender

    @classmethod
    def from_dict(cls, dikt) -> 'WriteUser':
        """Returns the dict as a model

        :param dikt: A dict.
        :type: dict
        :return: The WriteUser of this WriteUser.  # noqa: E501
        :rtype: WriteUser
        """
        return util.deserialize_model(dikt, cls)

    def validate(self):
        errors = []
        if self._username is None:
            errors.append({
                "code": "required",
                "field": "username",
                "message": "Invalid value for `username`, must not be `None`"  # noqa: E501
            })
        if self._username is not None and len(self._username) > 16:
            errors.append({
                "code": "maxLength",
                "field": "username",
                "message": "Invalid value for `username`, length must be less than or equal to `16`"  # noqa: E501
            })
        if self._first_name is None:
            errors.append({
                "code": "required",
                "field": "first_name",
                "message": "Invalid value for `first_name`, must not be `None`"  # noqa: E501
            })
        if self._last_name is None:
            errors.append({
                "code": "required",
                "field": "last_name",
                "message": "Invalid value for `last_name`, must not be `None`"  # noqa: E501
            })
        if self._email is None:
            errors.append({
                "code": "required",
                "field": "email",
                "message": "Invalid value for `email`, must not be `None`"  # noqa: E501
            })
        if self._password is None:
            errors.append({
                "code": "required",
                "field": "password",
                "message": "Invalid value for `password`, must not be `None`"  # noqa: E501
            })
        if self._password is not None and len(self._password) > 20:
            errors.append({
                "code": "maxLength",
                "field": "password",
                "message": "Invalid value for `password`, length must be less than or equal to `20`"  # noqa: E501
            })
        if self._password is not None and len(self._password) < 4:
            errors.append({
                "code": "minLength",
                "field": "password",
                "message": "Invalid value for `password`, length must be greater than or equal to `4`"  # noqa: E501
            })
        if self._phone is not None and self.is_not_digit(self._phone):
            errors.append({
                "code": "digit",
                "field": "phone",
                "message": "Invalid value for `phone`, must not be only digit"  # noqa: E501
            })
        if self._user_status is not None and self.is_not_int(self._user_status):
            errors.append({
                "code": "type",
                "field": "user_status",
                "message": "Invalid value for `user_status`, type must be `integer`"  # noqa: E501
            })
        if self._user_status is not None and self.is_not_in_code("userStatus", self._user_status):
            errors.append({
                "code": "codeType",
                "field": "user_status",
                "message": "Invalid value for `user_status`, must be one of code type `{}`".format("userStatus")  # noqa: E501
            })
        if self._height is not None and self.is_not_float(self._height):
            errors.append({
                "code": "type",
                "field": "height",
                "message": "Invalid value for `height`, type must be `float`"  # noqa: E501
            })
        if self._born_on is not None and self.is_not_datetime(self._born_on):
            errors.append({
                "code": "type",
                "field": "born_on",
                "message": "Invalid value for `born_on`, type must be `datetime`"  # noqa: E501
            })
        allowed_values = ["male", "female"]  # noqa: E501
        if self._gender not in allowed_values:
            errors.append({
                "code": "isContainer",
                "field": "gender",
                "message": "Invalid value for `gender` ({0}), must be one of {1}".format(
                    self._gender, allowed_values)  # noqa: E501
            })

        for attr, attr_type in self.swagger_types.items():
            # List[xxx] の場合
            if type(List) == type(attr_type):
                attr_values = getattr(self, attr)
                if not attr_values:
                    continue
                for i, attr_value in enumerate(attr_values):  # pylint: disable=E1133
                    attr_errors = attr_value.validate()
                    for attr_error in attr_errors:
                        attr_error["field"] = "{parent_attr}[{index}]{child_attr}".format(
                            parent_attr=attr, index=i, child_attr=attr_error["field"])
                    errors.extend(attr_errors)

            # Model のサブクラスの場合
            elif issubclass(attr_type, Model):
                attr_value = getattr(self, attr)
                if not attr_value:
                    continue
                attr_errors = attr_value.validate()
                for attr_error in attr_errors:
                    attr_error["field"] = "{parent_attr}.{child_attr}".format(
                        parent_attr=attr, child_attr=attr_error["field"])
                errors.extend(attr_errors)
        return errors

    @property
    def username(self) -> str:
        """Gets the username of this WriteUser.


        :return: The username of this WriteUser.
        :rtype: str
        """
        return self._username

    @username.setter
    def username(self, username: str):
        """Sets the username of this WriteUser.


        :param username: The username of this WriteUser.
        :type username: str
        """
        self._username = username

    @property
    def first_name(self) -> str:
        """Gets the first_name of this WriteUser.


        :return: The first_name of this WriteUser.
        :rtype: str
        """
        return self._first_name

    @first_name.setter
    def first_name(self, first_name: str):
        """Sets the first_name of this WriteUser.


        :param first_name: The first_name of this WriteUser.
        :type first_name: str
        """
        self._first_name = first_name

    @property
    def last_name(self) -> str:
        """Gets the last_name of this WriteUser.


        :return: The last_name of this WriteUser.
        :rtype: str
        """
        return self._last_name

    @last_name.setter
    def last_name(self, last_name: str):
        """Sets the last_name of this WriteUser.


        :param last_name: The last_name of this WriteUser.
        :type last_name: str
        """
        self._last_name = last_name

    @property
    def email(self) -> str:
        """Gets the email of this WriteUser.


        :return: The email of this WriteUser.
        :rtype: str
        """
        return self._email

    @email.setter
    def email(self, email: str):
        """Sets the email of this WriteUser.


        :param email: The email of this WriteUser.
        :type email: str
        """
        self._email = email

    @property
    def password(self) -> str:
        """Gets the password of this WriteUser.


        :return: The password of this WriteUser.
        :rtype: str
        """
        return self._password

    @password.setter
    def password(self, password: str):
        """Sets the password of this WriteUser.


        :param password: The password of this WriteUser.
        :type password: str
        """
        self._password = password

    @property
    def phone(self) -> str:
        """Gets the phone of this WriteUser.


        :return: The phone of this WriteUser.
        :rtype: str
        """
        return self._phone

    @phone.setter
    def phone(self, phone: str):
        """Sets the phone of this WriteUser.


        :param phone: The phone of this WriteUser.
        :type phone: str
        """
        self._phone = phone

    @property
    def user_status(self) -> int:
        """Gets the user_status of this WriteUser.

        User Status  # noqa: E501

        :return: The user_status of this WriteUser.
        :rtype: int
        """
        if self.is_not_int(self._user_status):
            return None
        return self._user_status

    @user_status.setter
    def user_status(self, user_status: int):
        """Sets the user_status of this WriteUser.

        User Status  # noqa: E501

        :param user_status: The user_status of this WriteUser.
        :type user_status: int
        """
        self._user_status = user_status

    @property
    def height(self) -> float:
        """Gets the height of this WriteUser.


        :return: The height of this WriteUser.
        :rtype: float
        """
        if self.is_not_float(self._height):
            return None
        return self._height

    @height.setter
    def height(self, height: float):
        """Sets the height of this WriteUser.


        :param height: The height of this WriteUser.
        :type height: float
        """
        self._height = height

    @property
    def born_on(self) -> datetime:
        """Gets the born_on of this WriteUser.


        :return: The born_on of this WriteUser.
        :rtype: datetime
        """
        if self.is_not_datetime(self._born_on):
            return None
        return self._born_on

    @born_on.setter
    def born_on(self, born_on: datetime):
        """Sets the born_on of this WriteUser.


        :param born_on: The born_on of this WriteUser.
        :type born_on: datetime
        """
        self._born_on = born_on

    @property
    def gender(self) -> str:
        """Gets the gender of this WriteUser.


        :return: The gender of this WriteUser.
        :rtype: str
        """
        return self._gender

    @gender.setter
    def gender(self, gender: str):
        """Sets the gender of this WriteUser.


        :param gender: The gender of this WriteUser.
        :type gender: str
        """
        self._gender = gender
